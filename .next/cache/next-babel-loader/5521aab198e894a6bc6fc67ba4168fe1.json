{"ast":null,"code":"import fs from \"fs\";\nimport matter from \"gray-matter\";\nimport path from \"path\";\nimport yaml from \"js-yaml\";\nconst postsDirectory = path.join(process.cwd(), \"src/pages/posts\");\nlet postCache;\n\nfunction fetchPostContent() {\n  if (postCache) {\n    return postCache;\n  } // Get file names under /posts\n\n\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostsData = fileNames.filter(it => it.endsWith(\".mdx\")).map(fileName => {\n    // Read markdown file as string\n    const fullPath = path.join(postsDirectory, fileName);\n    const fileContents = fs.readFileSync(fullPath, \"utf8\"); // Use gray-matter to parse the post metadata section\n\n    const matterResult = matter(fileContents, {\n      engines: {\n        yaml: s => yaml.safeLoad(s, {\n          schema: yaml.JSON_SCHEMA\n        })\n      }\n    });\n    const matterData = matterResult.data;\n    const slug = fileName.replace(/\\.mdx$/, \"\"); // Validate slug string\n\n    if (matterData.slug !== slug) {\n      throw new Error(\"slug field not match with the path of its content source\");\n    }\n\n    return matterData;\n  }); // Sort posts by date\n\n  postCache = allPostsData.sort((a, b) => {\n    if (a.date < b.date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  return postCache;\n}\n\nexport function countPosts(tag) {\n  return fetchPostContent().filter(it => !tag || it.tags && it.tags.includes(tag)).length;\n}\nexport function listPostContent(page, limit, tag) {\n  return fetchPostContent().filter(it => !tag || it.tags && it.tags.includes(tag)).slice((page - 1) * limit, page * limit);\n}","map":{"version":3,"sources":["/home/adelson/dev/new-blog/src/lib/posts.ts"],"names":["fs","matter","path","yaml","postsDirectory","join","process","cwd","postCache","fetchPostContent","fileNames","readdirSync","allPostsData","filter","it","endsWith","map","fileName","fullPath","fileContents","readFileSync","matterResult","engines","s","safeLoad","schema","JSON_SCHEMA","matterData","data","slug","replace","Error","sort","a","b","date","countPosts","tag","tags","includes","length","listPostContent","page","limit","slice"],"mappings":"AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,OAAOC,MAAP,MAAmB,aAAnB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,IAAP,MAAiB,SAAjB;AAEA,MAAMC,cAAc,GAAGF,IAAI,CAACG,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyB,iBAAzB,CAAvB;AASA,IAAIC,SAAJ;;AAEA,SAASC,gBAAT,GAA2C;AACzC,MAAID,SAAJ,EAAe;AACb,WAAOA,SAAP;AACD,GAHwC,CAIzC;;;AACA,QAAME,SAAS,GAAGV,EAAE,CAACW,WAAH,CAAeP,cAAf,CAAlB;AACA,QAAMQ,YAAY,GAAGF,SAAS,CAC3BG,MADkB,CACVC,EAAD,IAAQA,EAAE,CAACC,QAAH,CAAY,MAAZ,CADG,EAElBC,GAFkB,CAEbC,QAAD,IAAc;AACjB;AACA,UAAMC,QAAQ,GAAGhB,IAAI,CAACG,IAAL,CAAUD,cAAV,EAA0Ba,QAA1B,CAAjB;AACA,UAAME,YAAY,GAAGnB,EAAE,CAACoB,YAAH,CAAgBF,QAAhB,EAA0B,MAA1B,CAArB,CAHiB,CAKjB;;AACA,UAAMG,YAAY,GAAGpB,MAAM,CAACkB,YAAD,EAAe;AACxCG,MAAAA,OAAO,EAAE;AACPnB,QAAAA,IAAI,EAAGoB,CAAD,IAAOpB,IAAI,CAACqB,QAAL,CAAcD,CAAd,EAAiB;AAAEE,UAAAA,MAAM,EAAEtB,IAAI,CAACuB;AAAf,SAAjB;AADN;AAD+B,KAAf,CAA3B;AAKA,UAAMC,UAAU,GAAGN,YAAY,CAACO,IAAhC;AAMA,UAAMC,IAAI,GAAGZ,QAAQ,CAACa,OAAT,CAAiB,QAAjB,EAA2B,EAA3B,CAAb,CAjBiB,CAmBjB;;AACA,QAAIH,UAAU,CAACE,IAAX,KAAoBA,IAAxB,EAA8B;AAC5B,YAAM,IAAIE,KAAJ,CACJ,0DADI,CAAN;AAGD;;AAED,WAAOJ,UAAP;AACD,GA7BkB,CAArB,CANyC,CAoCzC;;AACAnB,EAAAA,SAAS,GAAGI,YAAY,CAACoB,IAAb,CAAkB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACtC,QAAID,CAAC,CAACE,IAAF,GAASD,CAAC,CAACC,IAAf,EAAqB;AACnB,aAAO,CAAP;AACD,KAFD,MAEO;AACL,aAAO,CAAC,CAAR;AACD;AACF,GANW,CAAZ;AAOA,SAAO3B,SAAP;AACD;;AAED,OAAO,SAAS4B,UAAT,CAAoBC,GAApB,EAA0C;AAC/C,SAAO5B,gBAAgB,GAAGI,MAAnB,CACJC,EAAD,IAAQ,CAACuB,GAAD,IAASvB,EAAE,CAACwB,IAAH,IAAWxB,EAAE,CAACwB,IAAH,CAAQC,QAAR,CAAiBF,GAAjB,CADvB,EAELG,MAFF;AAGD;AAED,OAAO,SAASC,eAAT,CACLC,IADK,EAELC,KAFK,EAGLN,GAHK,EAIU;AACf,SAAO5B,gBAAgB,GACpBI,MADI,CACIC,EAAD,IAAQ,CAACuB,GAAD,IAASvB,EAAE,CAACwB,IAAH,IAAWxB,EAAE,CAACwB,IAAH,CAAQC,QAAR,CAAiBF,GAAjB,CAD/B,EAEJO,KAFI,CAEE,CAACF,IAAI,GAAG,CAAR,IAAaC,KAFf,EAEsBD,IAAI,GAAGC,KAF7B,CAAP;AAGD","sourcesContent":["import fs from \"fs\";\nimport matter from \"gray-matter\";\nimport path from \"path\";\nimport yaml from \"js-yaml\";\n\nconst postsDirectory = path.join(process.cwd(), \"src/pages/posts\");\n\nexport type PostContent = {\n  readonly date: string;\n  readonly title: string;\n  readonly slug: string;\n  readonly tags?: string[];\n};\n\nlet postCache: PostContent[];\n\nfunction fetchPostContent(): PostContent[] {\n  if (postCache) {\n    return postCache;\n  }\n  // Get file names under /posts\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostsData = fileNames\n    .filter((it) => it.endsWith(\".mdx\"))\n    .map((fileName) => {\n      // Read markdown file as string\n      const fullPath = path.join(postsDirectory, fileName);\n      const fileContents = fs.readFileSync(fullPath, \"utf8\");\n\n      // Use gray-matter to parse the post metadata section\n      const matterResult = matter(fileContents, {\n        engines: {\n          yaml: (s) => yaml.safeLoad(s, { schema: yaml.JSON_SCHEMA }) as object,\n        },\n      });\n      const matterData = matterResult.data as {\n        date: string;\n        title: string;\n        tags: string[];\n        slug: string;\n      };\n      const slug = fileName.replace(/\\.mdx$/, \"\");\n\n      // Validate slug string\n      if (matterData.slug !== slug) {\n        throw new Error(\n          \"slug field not match with the path of its content source\"\n        );\n      }\n\n      return matterData;\n    });\n  // Sort posts by date\n  postCache = allPostsData.sort((a, b) => {\n    if (a.date < b.date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  return postCache;\n}\n\nexport function countPosts(tag?: string): number {\n  return fetchPostContent().filter(\n    (it) => !tag || (it.tags && it.tags.includes(tag))\n  ).length;\n}\n\nexport function listPostContent(\n  page: number,\n  limit: number,\n  tag?: string\n): PostContent[] {\n  return fetchPostContent()\n    .filter((it) => !tag || (it.tags && it.tags.includes(tag)))\n    .slice((page - 1) * limit, page * limit);\n}\n"]},"metadata":{},"sourceType":"module"}